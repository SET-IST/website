import { useState, useCallback } from 'react'
import { Anchor, Text } from '@mantine/core'

type TextTruncateProps = {
  text: string
}

/* Note: The number of lines to truncate to needs to be static
otherwise the css classes won't be generated by tailwind. If you need
a different number of lines, create a new component */
export const TruncatedText = ({ text }: TextTruncateProps) => {
  const [shouldTruncate, setShouldTruncate] = useState<boolean>(false)
  const [readMore, setReadMore] = useState<boolean>(false)

  // Measure the element to calculate the number of lines and
  // determine whether to truncate
  const measuredRef = useCallback(
    (node: any) => {
      // Before the component mounts the node ref will be null
      if (node?.parentElement) {
        // Calculate the number of lines based on height
        const elHeight = node.offsetHeight
        const styles = window.getComputedStyle(node)
        const lineHeight = styles
          .getPropertyValue('line-height')
          .replace('px', '')
        const elLineCount = elHeight / parseInt(lineHeight, 10)

        setShouldTruncate(elLineCount > 4)
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [text]
  )

  const shouldClamp = shouldTruncate && !readMore

  // Our toggle for expanding or hiding truncated text
  let toggle
  if (readMore) {
    toggle = (
      <Anchor fz="sm" component="button" onClick={() => setReadMore(false)}>
        Ocultar
      </Anchor>
    )
  } else {
    toggle = (
      <Anchor fz="sm" component="button" onClick={() => setReadMore(true)}>
        Expandir
      </Anchor>
    )
  }

  return (
    <Text className="sm:min-w-[18rem]" ta="center" c="dimmed" fw={500} fz="sm">
      <span
        ref={measuredRef}
        className={`${shouldClamp ? 'line-clamp-3' : 'line-clamp-none'}`}
      >
        {text}
      </span>
      {shouldTruncate && toggle}
    </Text>
  )
}
